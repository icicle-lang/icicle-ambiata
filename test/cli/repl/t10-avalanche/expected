welcome to iREPL
ok, loaded 20 functions from data/libs/prelude.icicle
ok, loaded test/cli/repl/data.psv, 13 rows
> -- Show everything
> ok, type is now on
ok, core is now on
ok, core-simp is now on
ok, core-type is now on
ok, avalanche is now on
ok, flatten is now on
> > -- A rather complicated feature to convert to Avalanche
> - Type:
Aggregate Possibly (Int, (Array Int))

- Core:
Program (source : Stream Int)
Precomputations:

Stream transformers:
conv$0 =
    source
conv$2 =
    sfilter [(Int, DateTime)] (
    \conv$3 : (Int, DateTime).  
    let simp$1 = fst# [Int] [DateTime]
                 conv$3
     in gt# [Int] simp$1 (10 : Int))
    conv$0
conv$7 =
    smap    [(Int, DateTime)] [Int]
    (
    \conv$8 : (Int, DateTime). 
    fst# [Int] [DateTime] conv$8)
    conv$0
Reductions:
c$conv$5 =
    rfold   [(Int, DateTime)]
    [Int] (
    \c$conv$5 : Int.  
    \conv$4 : (Int, DateTime). 
    add# [Int] c$conv$5 (1 : Int))
    (0 : Int) conv$2
conv$6 =
    rlatest [Int] (3 : Int)
    conv$7
Postcomputations with date as now$conv$1:
conv$9 =
    pair# [Int] [Array Int]
    c$conv$5 conv$6
Returning:
repl =
    conv$9


- Core type:
[(repl,(Int, Array Int))]

- Avalanche:
gen$date = DATE
{
  init [Latest] [Int] acc$conv$6 = 3 : Int;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in history {
    let gen$fact = pair# [Int] [DateTime]
                   elem$gen$fact elem$gen$date;
    let elem$conv$7 = fst# [Int] [DateTime]
                      gen$fact;
    push acc$conv$6(elem$conv$7);
  }
  init [Mutable] [Int] acc$c$conv$5 = 0 : Int;
  load_resumable [Int] acc$c$conv$5;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    let gen$fact = pair# [Int] [DateTime]
                   elem$gen$fact elem$gen$date;
    let anf$1 = fst# [Int] [DateTime]
                gen$fact;
    if (gt# [Int] anf$1
        (10 : Int)) {
      read [Mutable] [Int] acc$c$conv$5 = acc$c$conv$5;
      write acc$c$conv$5 = add# [Int]
                           acc$c$conv$5 (1 : Int);
    }
    let elem$conv$7 = anf$1;
    push acc$conv$6(elem$conv$7);
  }
  save_resumable [Int] acc$c$conv$5;
  read [Mutable] [Int] c$conv$5 = acc$c$conv$5;
  read [Latest] [Int] conv$6 = acc$conv$6;
  let conv$9 = pair# [Int] [Array Int]
               c$conv$5 conv$6;
  output repl conv$9;
}

- Flattened:
gen$date = DATE
{
  init [Latest] [Int] acc$conv$6 = 3 : Int;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in history {
    push acc$conv$6(elem$gen$fact);
  } 
  
  init [Mutable] [Int] acc$c$conv$5 = 0 : Int;
  load_resumable [Int] acc$c$conv$5;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    if (gt# [Int] elem$gen$fact
        (10 : Int)) {
      read [Mutable] [Int] acc$c$conv$5 = acc$c$conv$5;
      write acc$c$conv$5 = add# [Int]
                           acc$c$conv$5 (1 : Int);
    }
    push acc$conv$6(elem$gen$fact);
  }
  save_resumable [Int] acc$c$conv$5;
  read [Mutable] [Int] c$conv$5 = acc$c$conv$5;
  read [Latest] [Int] conv$6 = acc$conv$6;
  let conv$9 = pair# [Int] [Array Int]
               c$conv$5 conv$6;
  output repl conv$9;
}

- Core evaluation:
[homer, (5,[300,400,500])
,marge, (1,[0,10,20])]

> > 